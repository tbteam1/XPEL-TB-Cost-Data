---
title: "Xpel Sensitivity Analyses"
author: "Ryan Thompson"
date: "3/4/2021"
output: html_document
---
we could also set-up a parameter for the "fixed" service volume we multiply these all by.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Research Question: what are the costs/benefits of decentralized Xpert testing versus centralized Xpert testing?

#Scenario 1: 3871 patients (2019 Xpel service volume) receive Xpert testing at central testing facilities
#Scenario 2: 4135 patients (2019 Xpel service volume) receive Xpert testing at decentralized testing sites

#Inputs: The number of patients receiving Xpert testing, the proportion of those tested who began treatment within 2 weeks of test (other options: number positive tests, number positive tests) , costs
#Output 1: The number of patients initiating treatment within 2 weeks of receiving their test result.
#Output 2: The total costs of each program.
#Output 3: An incremental cost-effectiveness ratio estimating the incremental cost per additional TB positive patient initiating treatment within 2 weeks in the decentralized arm.

```{r packages}
library(ggplot2)
library(dplyr)
library(triangle)
library(car)
```

#First, set up the treatment.sim function by denoting all relevant input parameters youâ€™re doing PSA with, and then some function for coming up with your total costs and total effectiveness. (may just be an aggregate sum of each).


```{r create model parameters}
#UPDATE ALL
treatment.sim<-function(
  num.presenting, #the number of individuals presenting for care. Fixed between study arms
  cen.testedpro, #the proportion of indivuals presenting for care who receive testing in the centralized arm.
  cen.14daypro, #the proportion of patients tested who are confirmed TB positive and initiate treatment within 14 days in the centralized arm (default value = 4.57%)
  decen.testedpro, #the proportion of individuals presenting for care who receive testing in the decentralized arm.
  decen.14daypro, #the proportion of patients tested who are confirmed TB positive and initiate treatment within 14 days in the decentralized arm (default value = 6.02%)
  cen.consumable.cost, # the fixed per-test cost of consumables in the centralized testing arm (default = $11.65. Observed Range: $11.35-12.04)
  cen.staff.cost, #the staff costs for centralized testing (default = $0.49, Observed Range: $0.07-1.20)
  cen.equipment.cost, #the equipment costs for centralized testing (default = $3.82, Observed Range: $1.88-7.93)
  cen.building.cost, #the building costs for centralized testing (default = $0.35, Observed Range: $0.17-0.72)
  cen.overhead.cost, #the overhead costs for centralized testing (default = $0.01, Observed Range: $0.01-0.03)
  cen.transport.cost, #the transportation costs for centralized testing (fixed at $1.34)
  decen.consumable.cost, # the fixed per-test cost of consumables in the decentralized testing arm (default = $10.84. Observed Range: $10.82-10.98)
  decen.staff.cost, #the staff costs for decentralized testing (default = $0.51, Observed Range: $0.19-0.83)
  decen.equipment.cost, #the equipment costs for decentralized testing (default = $6.79, Observed Range: $5.23-11.20)
  decen.building.cost, #the building costs for decentralized testing (default = $0.03, Observed Range: $0.02-0.06)
  decen.overhead.cost, #the overhead costs for decentralized testing (default = $0.03, Observed Range: $0.02-0.05)
  decen.impl.cost, #the implementation costs for decentralized testing (default = $1.47, Observed Range: $1.13-$2.43)
  decen.main.cost, #the maintenance costs for decentralized testing (default = $0.79, Observed Range: $0.42-1.96)
  cen.error.term, #An error term to avoid "perfect" correlation, it is +/- 10% of the observed "total cost per patient" in each study arm. The variable is for the centralized arm.
  decen.error.term, #Error term for the decentralized arm.
  decen.propositive, #Proportion of tests positive (ignore treatment initiation) in decen
  cen.propositive, #Proportion of tests positive (ignore treatmnet initiation) in cen
  cen.ssm.cost
  #cen.percent.smm, #percent of patients that receive a ssm (ssm only + both)
  #cen.percent.xpert #percent that receive xpert (xpert only + both)
  
){ #Here, set up our values of interest (total cost and # of patients initiating treatment)
  cen.numtest <- num.presenting * cen.testedpro
  cen.primary <- cen.numtest * cen.14daypro #The total number of patients initiating treatment within 14 days
  #Next, calculate the total costs for each cost category
  
  cen.consumable.cost <- cen.consumable.cost
  cen.consumable.totcost <- (cen.consumable.cost * cen.numtest)
  
  cen.staff.cost <- cen.staff.cost
  cen.staff.totcost <- (cen.staff.cost * cen.numtest)
  
  cen.equipment.cost.corr <- (cen.equipment.cost / cen.numtest)
  cen.equipment.totcost <- (cen.equipment.cost.corr * cen.numtest) #Function set-up so that equipment cost inversely related to number tested
  
  cen.building.cost <- cen.building.cost
  cen.building.totcost <- (cen.building.cost * cen.numtest)
  
  cen.overhead.cost <- cen.overhead.cost
  cen.overhead.totcost <- (cen.overhead.cost * cen.numtest)
  
  cen.transport.cost <- cen.transport.cost
  cen.transport.totcost <- (cen.transport.cost * cen.numtest)
  
  cen.ssm.cost <- cen.ssm.cost
  cen.ssm.totcost <- (cen.ssm.cost * cen.numtest)

  
   #### NEW
  cen.pp.cost.old <- (cen.consumable.cost + cen.staff.cost + cen.equipment.cost.corr + cen.building.cost + cen.overhead.cost + cen.transport.cost + cen.ssm.cost) * cen.error.term
  
  cen.pp.cost.old.no.ssm <- (cen.consumable.cost + cen.staff.cost + cen.equipment.cost.corr + cen.building.cost + cen.overhead.cost + cen.transport.cost) * cen.error.term
  
   
  #cen.percent.smm <- cen.percent.smm
  #cen.percent.xpert <- cen.percent.xpert
  
  cen.pp.cost.ssm <- (cen.ssm.cost * 0.8)
  
  cen.pp.cost.xpert <- ((cen.consumable.cost + cen.staff.cost + cen.equipment.cost.corr + cen.building.cost + cen.overhead.cost + cen.transport.cost) * 0.42)
  
  cen.pp.cost <- cen.pp.cost.ssm + cen.pp.cost.xpert
  
  cen.pp.cost.error <- (cen.pp.cost * cen.error.term)
  
  ####
  
  
  
  cen.total.cost <- (cen.consumable.totcost + cen.staff.totcost + cen.equipment.totcost + cen.building.totcost + cen.overhead.totcost + cen.transport.totcost + cen.ssm.totcost) #Total cost for the arm
  
  cen.total.cost.error <- (cen.pp.cost.error * cen.numtest) #uses empiric SV instead of 5,000 patients--THIS IS THE ONE TO USE
  
  
######################################################################################################### DECENTRALIZED ############################ ##########################################################################

  decen.numtest <- num.presenting * decen.testedpro
  decen.primary <- decen.numtest * decen.14daypro #The total number of patients initiating treatment within 14 days.
  #Next, calculate the total costs for each cost category
  
  decen.consumable.cost <- decen.consumable.cost
  decen.consumable.totcost <- (decen.consumable.cost * 5000)
  
  decen.staff.cost <- decen.staff.cost
  decen.staff.totcost <- (decen.staff.cost * 5000)
  
  decen.equipment.cost.corr <- (decen.equipment.cost / decen.numtest)
  decen.equipment.totcost <- (decen.equipment.cost.corr * 5000) #For this one, may want to set up a function so equipment cost decreases with service volume
  
  decen.building.cost <- decen.building.cost
  decen.building.totcost <- (decen.building.cost * 5000)
  
  decen.overhead.cost <- decen.overhead.cost
  decen.overhead.totcost <- (decen.overhead.cost * 5000)
  
  decen.impl.cost.corr <- (decen.impl.cost / decen.numtest)
  decen.impl.totcost <- (decen.impl.cost.corr * 5000)
  
  decen.main.cost <- decen.main.cost  
  decen.main.totcost <- (decen.main.cost * 5000)
  
  decen.pp.cost <- (decen.consumable.cost + decen.staff.cost + decen.equipment.cost.corr + decen.building.cost + decen.overhead.cost + decen.impl.cost.corr + decen.main.cost) * 0.99
  
  decen.pp.cost.error <- (decen.pp.cost * decen.error.term)
  
  decen.total.cost <- (decen.consumable.totcost + decen.staff.totcost + decen.equipment.totcost + decen.building.totcost + decen.overhead.totcost + decen.impl.totcost + decen.main.totcost) #Total cost for the decentralized arm
  
  #decen.total.cost.error <- (decen.total.cost + (decen.error.term * 5000))
  decen.total.cost.error <- decen.pp.cost.error * decen.numtest
  
  ########### ICER VALUES #############
  
  incr.total.cost <- (decen.total.cost.error - cen.total.cost.error)
  incr.total.effect <- (decen.primary - cen.primary)
  incr.ratio <- (incr.total.cost / incr.total.effect)
  
  decen.dxpos <- decen.numtest * decen.propositive
  cen.dxpos <- cen.numtest * cen.propositive
  dx.incr.effect <- (decen.dxpos - cen.dxpos)
  dx.icer <- (incr.total.cost / dx.incr.effect)
  
  #cost-effectiveness unit costs
  cost.per.dx.cen = (cen.total.cost.error / cen.dxpos)
  cost.per.dx.decen = (decen.total.cost.error / decen.dxpos)
  cost.per.init.cen = (cen.total.cost.error / cen.primary)
  cost.per.init.decen = (decen.total.cost.error / decen.primary)
  
  #return the key results: cure and cost in each scenario
  
  results<-c(num.presenting,
             cen.testedpro,
             cen.numtest, 
             cen.14daypro, 
             cen.primary, 
             cen.consumable.cost,
             cen.consumable.totcost, 
             cen.staff.cost,
             cen.staff.totcost, 
             cen.equipment.cost.corr,
             cen.equipment.totcost,
             cen.building.cost,
             cen.building.totcost, 
             cen.overhead.cost,
             cen.overhead.totcost, 
             cen.transport.cost,
             cen.transport.totcost,
             cen.pp.cost,
             cen.pp.cost.error,
             cen.total.cost,
             cen.total.cost.error,
             decen.testedpro,
             decen.numtest, 
             decen.14daypro, 
             decen.primary, 
             decen.consumable.cost,
             decen.consumable.totcost, 
             decen.staff.cost,
             decen.staff.totcost, 
             decen.equipment.cost.corr,
             decen.equipment.totcost,
             decen.building.cost,
             decen.building.totcost,
             decen.overhead.cost,
             decen.overhead.totcost,
             decen.impl.cost.corr,
             decen.impl.totcost,
             decen.main.cost,
             decen.main.totcost,
             decen.pp.cost,
             decen.pp.cost.error,
             decen.total.cost,
             decen.total.cost.error,
             incr.total.cost,
             incr.total.effect,
             incr.ratio,
             decen.propositive,
             cen.propositive,
             decen.dxpos,
             cen.dxpos,
             dx.incr.effect,
             dx.icer,
             cen.ssm.cost,
             cen.ssm.totcost,
             #cen.percent.smm, 
             #cen.percent.xpert,
             cen.pp.cost.ssm,
             cen.pp.cost.xpert,
             cen.pp.cost.old,
             cen.pp.cost.old.no.ssm,
             cost.per.dx.cen,
             cost.per.dx.decen,
             cost.per.init.cen,
             cost.per.init.decen) 
  
  names(results)<-c("Number presenting for care",
                    "Prop who are tested",
                    "Cen number tested",
                    "Cen Proportion 1ary outcome",
                    "Cen 1ary outcome",
                    "Cen Consumable costs",
                    "Cen Consumable Tot costs",
                    "Cen Staff costs",
                    "Cen Staff Tot costs",
                    "Cen Equip costs",
                    "Cen Equip Tot costs",
                    "Cen Build costs",
                    "Cen Build Tot costs",
                    "Cen Overhead costs",
                    "Cen Overhead Tot costs",
                    "Cen Transport costs",
                    "Cen Transport Tot costs",
                    "Cen Per Patient costs",
                    "Cen Per Pt costs w/ error",
                    "Cen Total costs",
                    "Cen Total costs w/ error",
                    "Decen prop tested",
                    "Decen number tested",
                    "Decen Proportion 1ary outcome",
                    "Decen 1ary outcome",
                    "Decen Consumable costs",
                    "Decen Consumable Tot costs",
                    "Decen Staff costs",
                    "Decen Staff Tot costs",
                    "Decen Equip costs",
                    "Decen Equip Tot costs",
                    "Decen Build costs",
                    "Decen Build Tot costs",
                    "Decen Overhead costs",
                    "Decen Overhead Tot costs",
                    "Decen Impl costs",
                    "Decen Impl Tot costs",
                    "Decen Main costs",
                    "Decen Main Tot costs",
                    "Decen Per Patient costs",
                    "Decen Per Pt costs w/ error",
                    "Decen Total costs",
                    "Decen Total costs w/ error",
                    "Incr Total Cost",
                    "Incr Total Effect",
                    "ICER",
                    "Decen Proportion Pos",
                    "Cen Proportion Pos",
                    "Decen # Pos",
                    "Cen # Pos",
                    "Incr # Tested",
                    "ICER Dx",
                    "Cost SSM Cen",
                    "Tot Cost SSM Cen",
                    #"% Receive SSM",
                    #"% Receive Xpert",
                    "SSM Cost per Patient",
                    "Xpert Cost per Patient",
                    "Old per patient cost",
                    "Old per patient cost, no ssm",
                    "Cost per Dx, Cen",
                    "Cost per Dx, Decen",
                    "Cost per init, Cen",
                    "Cost per init, Decen"
                    )
  
  return(results)
}
```

```{r set-up the parameter values}
param.ranges<-data.frame("variable"=character(23),
                         "distribution"=character(23),
                         "parameter1"=numeric(23),
                         "parameter2"=numeric(23),
                         "parameter3"=numeric(23),
                         "parameter1.name"=numeric(23), 
                         "parameter2.name"=numeric(23),
                         "parameter3.name"=numeric(23))

param.ranges[,"variable"]<-c(
"num.presenting",
"cen.testedpro",
"cen.14daypro",
"decen.testedpro",
"decen.14daypro",
"cen.consumable.cost",
"cen.staff.cost",
"cen.equipment.cost",
"cen.building.cost",
"cen.overhead.cost",
"cen.transport.cost", 
"decen.consumable.cost",
"decen.staff.cost",
"decen.equipment.cost",
"decen.building.cost",
"decen.overhead.cost", 
"decen.impl.cost",
"decen.main.cost",
"cen.error.term",
"decen.error.term",
"decen.propositive",
"cen.propositive",
"cen.ssm.cost"
#"cen.percent.smm", 
#"cen.percent.xpert"
)
#Assigns a name to each of the above variables in the param.ranges data frame.

param.ranges[,"distribution"]<-c(
"beta", #Number presenting for care
"beta", #Proportion presenting who are tested
"beta", #Proportion cases that are positive, cen
"beta", #Proportion presenting who are tested (decen)
"beta", #Proportion cases that are positive, decent
"beta", #consumable
"beta", #staff
"beta", #equipment
"beta", #building
"beta", #overhead
"beta", #transport
"beta", #consumable
"beta", #staff
"beta", #equipment
"beta", #building
"beta", #overhead
"beta", #implementation
"beta", #maintenance
"beta", #cen error term
"beta", #decen error term
"beta", #decen prop. positive
"beta", #cen prop. positive
"beta" #cost ssm cen
#"beta", #percent getting SSM
#"beta" #percent getting Xpert
)
#Assigns a distribution to each parameter. Note: common cost distributions are uniform, normal, triangular, and beta.

#ALL UPDATED FOR INFLATION
param.ranges[,"parameter1"]<-c(
  1340, #Number presenting for care
  0.8862, #proportion presenting who are tested, cen 25% below
  0.0412, #Proportion cases that are positive, 25% below PE
  1, #proportion presenting who are tested, -5% of PE
  0.0538, #Proportion cases that positive, decent, 25% below PE
  11.67, #consumable cen
  0.09, #staff cen
  22896.84, #equipment cen
  0.18, #building cen
  0.01, #overhead cen
  0.27, #transport cen
  10.82, #consumable decen
  0.19, #staff decen
  33969.025, #equipment decen
  0.02, #building decen
  0.02, #overhead decen
  7360.30, #implementation decen
  0.42, #maintenance decen
  0.9, #cen error term
  0.9, #decen error term
  0.06203, #decen prop positive
  0.05813, #cen prop positive
  2.04 #ssm cen
  #0.80, #percent getting SSM
  #0.42 #percent getting Xpert
)
param.ranges[,"parameter2"]<-c(
  6410, #Number presenting for care
  0.9862, #proportion presenting who are tested, cen +5% of PE
  0.0503, #Proportion cases that positive, cen, 
  1, #proportion presenting who are tested, decen
  0.0657, #Proportion cases that positive, decent, 25% above PE
  12.53, #consumable cen
  1.49, #staff cen
  22896.84, #equipment cen
  0.89, #building cen
  0.04, #overhead cen
  3.71, #transport cen
  10.98, #consumable decen
  0.83, #staff decen
  33969.025, #equipment decen
  0.06, #building decen
  0.05, #overhead decen
  7360.30, #implementation decen
  1.96, #maintenance decen
  1.1, #cen error term
  1.1, #decen error term
  0.07581, #decen prop positive
  0.07104, #cen prop positive
  2.95 #ssm cen
  #0.80, #percent getting SSM
  #0.42 #percent getting Xpert
)
param.ranges[,"parameter3"]<-c(
  4137, #Number presenting for care
  0.9362, #proportion presenting who are tested, cen
  0.0457, #Proportion cases that are positive, cen
  1, #proportion presenting who are tested, decen
  0.0597, #Proportion cases that are positive, decent
  12.05, #consumable cen
  0.61, #staff cen
  22896.84, #equipment cen
  0.35, #building cen
  0.01, #overhead cen
  1.38, #transport cen
  10.84, #consumable decen
  0.51, #staff decen
  33969.025, #equipment decen
  0.03, #building decen
  0.03, #overhead decen
  7360.30, #implementation decen
  0.79, #maintenance decen
  1, #cen error term
  1, #decen error term
  0.0689, #decen prop positive
  0.0646, #cen prop positive
  2.41 #ssm cen
  #0.80, #percent getting SSM
  #0.42 #percent getting Xpert
)
#Parameter 1 is min, 2 is max, 3 is PE
```


```{r add the alpha and beta values}
#Updated with inflation
param.ranges[,"parameter1.name"]<-c( #The ALPHA value
  4, #number presenting for care
  4, #central proportion tested
  4, #central proportion TB+
  4, #decen proportion tested
  4, #decentral proportion TB+
  4, #central consumable costs
  4, #central staff costs
  4, #central equipment costs
  4, #central building costs
  4, #central overhead costs
  4, #central transport costs
  4, #decen consumable costs
  4, #decen staff costs
  4, #decen equipment costs
  4, #decen building costs
  4, #decen overhead costs
  4, #decen implementation costs
  4, #decen maintenance costs
  4, #cen error term
  4, #decen error term
  4, #decen prop positive
  4, #cen prop positive
  4 #cost ssm cen
  #4, #percent getting SSM
  #4 #percent getting Xpert
  )
  
param.ranges[,"parameter2.name"]<-c( #The BETA value
  3.277, #total number tested
  4, #central proportion tested
  3.980434, #central proportion TB+
  1, #decen proprtion tested
  4, #decentral proportion TB+
  4.798187, #central consumable costs
  6.076922, #central staff costs
  1, #central equipment costs
  10.52941, #central building costs
  88, #central overhead costs
  7.2965603, #central transport costs
  22, #decen consumable costs
  4, #decen staff costs
  1, #decen equipment costs
  10, #decen building costs
  7, #decen overhead costs
  1, #decen implementation costs
  10.48649, #decen maintenance costs
  4, #cen error term
  4, #decen error term
  4, #decen prop pos
  4, #den prop pos
  5.39 #cost ssm cen
  #4, #percent getting SSM
  #4 #percent getting Xpert
  )
  
param.ranges[,"parameter3.name"]<-c(#Non-centrality parameter, ask David/Hojoon what that is
  0, #number presenting
  0, #central proprtion tested
  0, #central proportion TB+ and start 14 days
  0, #decen proportion tested
  0, #decentral proportion TB+ and start 14 days
  0, #central consumable costs
  0, #central staff costs
  0, #central equipment costs
  0, #central building costs
  0, #central overhead costs
  0, #central transport costs
  0, #decen consumable costs
  0, #decen staff costs
  0, #decen equipment costs
  0, #decen building costs
  0, #decen overhead costs
  0, #decen implementation costs
  0, #decen maintenance costs
  0, #cen error term
  0, #decen error term
  0, #decen prop pos
  0, #cen prop pos
  0 #cost ssm cen
  #0 #percent getting SSM
  #0 #percent getting Xpert
  )


```

```{r simulation prep, repetitions and matrix}
#Define the number of simulations you intend to perform
set.seed(269130)
n.sims<-1000


#Create a matrix to hold all of the sampled parameter values
#Each row will represent 1 simulation; the columns in the row will correspond to the sampled parameter values for the row
sampled.values<-matrix(nrow=n.sims,ncol=nrow(param.ranges))
colnames(sampled.values)<-param.ranges[,"variable"]

#Loop over the parameters (columns in sampled.values, rows in param.ranges) that will be sampled
for(p in 1:ncol(sampled.values)){
  
  #check for the distribution that will be used
  #check for a uniform distribution
  if(param.ranges[p,"distribution"]=="uniform"){
    
    n.params<-runif( #sample from a uniform distribution
      n.sims, #how many samples to draw = the number of simulations you will perform
      min=param.ranges[p,"parameter1"], #define the lower bound parameter
      max=param.ranges[p,"parameter2"] #define the upper bound
    )
    #exit the if-loop and go to the end
    
  }
  #if not uniform, check if it is normal
  if(param.ranges[p,"distribution"]=="normal"){
    
    n.params<-rnorm( #sample from a normal distribution
      n.sims, #how many samples to draw = the number of simulations you will perform
      mean=param.ranges[p,"parameter1"], #define the lower bound parameter
      sd=param.ranges[p,"parameter2"] #define the upper bound
    )
    #exit the if-loop and go to the end
    
  }
  
  #if not uniform, check if it is lognormal
  if(param.ranges[p,"distribution"]=="lognormal"){
    
    n.params<-rlnorm( #sample from a log-normal distribution
      n.sims, #how many samples to draw = the number of simulations you will perform
      meanlog=param.ranges[p,"parameter1"], #define the mean parameter
      sdlog=param.ranges[p,"parameter2"] #define the standard deviation parameter
    )
    #exit the if-loop and go to the end
    
  }
  
  #if not lognormal, check if it is gamma
  if(param.ranges[p,"distribution"]=="gamma"){
    n.params<-rgamma( #sample from a log-normal distribution
      n.sims, #how many samples to draw = the number of simulations you will perform
      shape=param.ranges[p,"parameter1"], #define the k parameter
      scale=param.ranges[p,"parameter2"] #define the theta parameter
    )
    #exit the if-loop and go to the end
    
  }
  
  #if not gamma, check if it is triangular
  if(param.ranges[p,"distribution"]=="triangular"){
    n.params<- rtriangle( #sample from a triangular distribution
      n.sims, #how many samples to draw = the number of simulations you will perform
      a = param.ranges[p,"parameter1"], #define the lower bound paramater/parameter input 1
      b = param.ranges[p,"parameter2"], #define the upper bound parameter
      c = param.ranges[p,"parameter3"] #define the mode/central tendency parameter
    )
  }
  
  #if not triangular, check if it is beta
  if(param.ranges[p,"distribution"]=="beta"){
    n.params<- rbeta( #sample from a beta distribution
      n.sims, #how many samples to draw = the number of simulations you will perform
      shape1 = param.ranges[p,"parameter1.name"], #define the alpha shape parameter
      shape2 = param.ranges[p,"parameter2.name"], #define the beta shape parameter
      ncp = param.ranges[p,"parameter3.name"] #define the non-centrality parameter (should be 0)
    ) 
    #(parameter1 + (p *(parameter2 - parameter1)))
  }
  sampled.values[,p]<-n.params #fill the column of the matrix with the vector of sampled values
  
  #go to the next column
}

```



```{r calculate "true" simulated values}
#Change variable names to match 99DOTS, no other changes
num.presenting <- (sampled.values[,1] * (param.ranges[1,4] - param.ranges[1,3])) + param.ranges[1,3]

cen.testedpro <- (sampled.values[,2] * (param.ranges[2,4] - param.ranges[2,3])) + param.ranges[2,3] #For central testing volume

cen.14daypro <- (sampled.values[,3] * (param.ranges[3,4] - param.ranges[3,3])) + param.ranges[3,3] #For proportion of cases tested that are TB+

decen.testedpro <- (sampled.values[,4] * (param.ranges[4,4] - param.ranges[4,3])) + param.ranges[4,3] #Decent testing volume

decen.14daypro <- (sampled.values[,5] * (param.ranges[5,4] - param.ranges[5,3])) + param.ranges[5,3] #Proportion tested with TB, decentralized

cen.consumable.cost <- (sampled.values[,6] * (param.ranges[6,4] - param.ranges[6,3])) + param.ranges[6,3] #Cen consumable cost

cen.staff.cost <- (sampled.values[,7] * (param.ranges[7,4] - param.ranges[7,3])) + param.ranges[7,3] #Cen staff cost

cen.equipment.cost <- (sampled.values[,8] * (param.ranges[8,4] - param.ranges[8,3])) + param.ranges[8,3] #Cen equipment cost

cen.building.cost <- (sampled.values[,9] * (param.ranges[9,4] - param.ranges[9,3])) + param.ranges[9,3] #Cen building cost

cen.overhead.cost <- (sampled.values[,10] * (param.ranges[10,4] - param.ranges[10,3])) + param.ranges[10,3] #Cen overhead cost, double check this one

cen.transport.cost <- (sampled.values[,11] * (param.ranges[11,4] - param.ranges[11,3])) + param.ranges[11,3] #Cen transport cost

decen.consumable.cost <- (sampled.values[,12] * (param.ranges[12,4] - param.ranges[12,3])) + param.ranges[12,3] #Decen consumable cost

decen.staff.cost <- (sampled.values[,13] * (param.ranges[13,4] - param.ranges[13,3])) + param.ranges[13,3] #Decen staff cost

decen.equipment.cost <- (sampled.values[,14] * (param.ranges[14,4] - param.ranges[14,3])) + param.ranges[14,3] #Decen equipment cost

decen.building.cost <- (sampled.values[,15] * (param.ranges[15,4] - param.ranges[15,3])) + param.ranges[15,3] #Decen building cost

decen.overhead.cost <- (sampled.values[,16] * (param.ranges[16,4] - param.ranges[16,3])) + param.ranges[16,3] #Decen overhead cost

decen.impl.cost <- (sampled.values[,17] * (param.ranges[17,4] - param.ranges[17,3])) + param.ranges[17,3] #Decen implementation cost

decen.main.cost <- (sampled.values[,18] * (param.ranges[18,4] - param.ranges[18,3])) + param.ranges[18,3] #Decen maintenance costs

cen.error.term <- (sampled.values[,19] * (param.ranges[19,4] - param.ranges[19,3])) + param.ranges[19,3] #Cen error term

decen.error.term <- (sampled.values[,20] * (param.ranges[20,4] - param.ranges[20,3])) + param.ranges[20,3] #

decen.propositive <- (sampled.values[,21] * (param.ranges[21,4] - param.ranges[21,3])) + param.ranges[21,3] #

cen.propositive <- (sampled.values[,22] * (param.ranges[22,4] - param.ranges[22,3])) + param.ranges[22,3] #

cen.ssm.cost <- (sampled.values[,23] * (param.ranges[23,4] - param.ranges[23,3])) + param.ranges[23,3] #cen ssm cost

#cen.percent.ssm <- (sampled.values[,24] * (param.ranges[24,4] - param.ranges[24,3])) + param.ranges[24,3] #cen ssm cost

#cen.percent.xpert <- (sampled.values[,25] * (param.ranges[25,4] - param.ranges[25,3])) + param.ranges[25,3] #cen ssm cost

#Change to reflect 99DOTS values
sampled.values.true <- cbind(num.presenting,
                           cen.testedpro,
                           cen.14daypro,
                           decen.testedpro,
                           decen.14daypro,
                           cen.consumable.cost,
                           cen.staff.cost,
                           cen.equipment.cost,
                           cen.building.cost,
                           cen.overhead.cost,
                           cen.transport.cost,
                           decen.consumable.cost,
                           decen.staff.cost,
                           decen.equipment.cost,
                           decen.building.cost,
                           decen.overhead.cost,
                           decen.impl.cost,
                           decen.main.cost,
                           cen.error.term,
                           decen.error.term,
                           decen.propositive,
                           cen.propositive,
                           cen.ssm.cost
                           #cen.percent.ssm,
                          # cen.percent.xpert
                           )

                             
```

```{R Run the Simulations}
#NO CHANGES
#Perform your simulations using a combination of apply() and do.call()
#apply() will iteratively perform the same function to each row and/or column of a matrix argument
#The matrix of sampled input values will serve as our matrix argument X
#We will set MARGIN=1 to indicate that we want to iterate over the rows (not columns) of the matrix
#We will create a custom function to apply over each row (r)
#The key of the custom function is do.call() 
#do.call() calls a function of your choice and passes user-defined arguments to it
#we will use it to call our previously-defined function treatment.sim()
#We will supply it our row of sampled input values as user-defined arguments
#arguments for do.call() must be in the form of a list: as.list(r)
#apply() returns the outputs of each iteration as a column of a matrix
#for ease of use, we will transpose - t() - the matrix so that each iteration will be returned as a row

sim.out<-t(apply(X=sampled.values.true,MARGIN=1, FUN=function(r) do.call(what=treatment.sim, args=as.list(r)) ))
#for each row of sampled.values, run function r which is our treatment.sim formula.
sim.out.df <- as.data.frame(sim.out)



#Becase treatment.sim() returns a vector of 4 results ("Scenario1.Cure","Scenario1.Cost","Scenario2.Cure","Scenario2.Cost")
#sim.out contains 4 columns, each corresponding to one of the outputs of treatment.sim()
#The first row of sim.out corresponds to the results of the simulation created by the first row of sampled input values in sampled.value
```

```{r cost-effect}
sim.out.df <- sim.out.df %>% mutate(cost.per.dx.cen = (sim.out.df$cen.total.cost.error / sim.out.df$cen.dxpos))
```


```{r ICER values}
#Change columns to match sim.out.df in 99DOTS
ICER<-matrix(ncol=7,nrow=nrow(sim.out.df))
colnames(ICER)<-c("Incremental Effectiveness","Incremental Cost", "Ratio", "Cost.Trmt.Dec", "Cost.Trmt.Cen", "Cost.Dx.Dec", "Cost.Dx.Cen")

ICER[,1]<-sim.out.df[,25]-sim.out.df[,5] #99DOTS effectivenss - no DOTS total effectiveness
ICER[,2]<-sim.out.df[,43]-sim.out.df[,21] #99DOTS total cost - no DOTS total costs
ICER[,3]<-ICER[,2]/ICER[,1] #No change

#Cost-effectiveness outcomes
ICER[,4]<-sim.out.df[,43]/sim.out.df[,25] #Decen cost/tx
ICER[,5]<-sim.out.df[,21]/sim.out.df[,5] #Cen cost/tx
ICER[,6]<-sim.out.df[,43]/sim.out.df[,49] #Decen cost/dx
ICER[,7]<-sim.out.df[,21]/sim.out.df[,50] #Cen cost/dx

ICER.df <- data.frame(ICER)
mean_effect <- mean(ICER.df$Incremental.Effectiveness)
mean_cost <- mean(ICER.df$Incremental.Cost)
mean_icer <- mean(ICER.df$Ratio)
median_icer <- median(ICER.df$Ratio)
mean_cost_decen <- mean(sim.out.df$`Decen Per Pt costs w/ error`)
median_icer <- median(sim.out.df$ICER)

print(paste("Mean Incremental Effectiveness =", mean_effect, "add'l trt initiations"))
print(paste("Mean Incremental Cost = ", mean_cost, "add'l costs"))
print(paste("Median ICER Trt Init = ", median_icer, "per add'l trt init"))
quantile(ICER.df[,3],0.025)
quantile(ICER.df[,3],0.975)
mean(sim.out.df$`Cen Total costs w/ error`)
mean(sim.out.df$`Decen Total costs w/ error`)
mean(sim.out.df$`Decen Per Pt costs w/ error`)
mean(sim.out.df$`Cen Per Pt costs w/ error`)
mean(sim.out.df$`Old per patient cost`)
mean(sim.out.df$`SSM Cost per Patient`)
mean(sim.out.df$`Xpert Cost per Patient`)
mean(sim.out.df$`Cost SSM Cen`)
mean(sim.out.df$`Old per patient cost, no ssm`)
mean(sim.out.df$`Number presenting for care`)

print("Median Cost per Trt Init, Decen = ") 
median(ICER.df$Cost.Trmt.Dec)
quantile(ICER.df[,4],0.025)
quantile(ICER.df[,4],0.975)

print("Median Cost per Trt Init, Cen = ") 
median(ICER.df$Cost.Trmt.Cen)
quantile(ICER.df[,5],0.025)
quantile(ICER.df[,5],0.975)

print("Median Cost per Dx, Decen = ") 
median(ICER.df$Cost.Dx.Dec)
quantile(ICER.df[,6],0.025)
quantile(ICER.df[,6],0.975)

print("Median Cost per Dx, Cen = ") 
median(ICER.df$Cost.Dx.Cen)
quantile(ICER.df[,7],0.025)
quantile(ICER.df[,7],0.975)
```


```{r Plot}
#Change labels
dataEllipse(ICER[,1],ICER[,2],
     xlab="Incremental Patients Initiated on Trtmt w/in 14 Days",
     ylab="Incremental Total Costs ($)",
     main="Incremental Cost-Effectiveness",
     pch=16,xaxs="i",yaxs="i",
     levels = 0.95,
     col=c("azure4", "blue"))
abline(h=0,lty=2)
abline(v=0,lty=2)

```

```{r CE Acceptability Curve}
acceptable<- c( ICER[which(ICER[,2]>=0 & ICER[,1]>=0),"Ratio"],
                rep(0,length(which(ICER[,2]<=0 & ICER[,1]>=0))),
                rep(Inf,length(which( ICER[,1]<=0)))
                
)


#Change labels
plot(ecdf( acceptable ),
     xlim=c(0,quantile(acceptable[acceptable!=Inf],probs=0.99)),
     ylim=c(0,1),
     xlab="Willingness to Pay Threshold\n(per Additional Case Initiated on Treatment)",
     ylab="Probability of being\nCost-Effective",
     main="Cost-Effectiveness Acceptability Curve",
     xaxs="i",yaxs="i",
     col="black"
)
```

```{r proportion at different WTP}
under100 <- sim.out.df %>% filter(ICER <= 100)
under200 <- sim.out.df %>% filter(ICER <= 200)
under300 <- sim.out.df %>% filter(ICER <= 300)
under400 <- sim.out.df %>% filter(ICER <= 400)
under500 <- sim.out.df %>% filter(ICER <= 500)
under600 <- sim.out.df %>% filter(ICER <= 600)
under700 <- sim.out.df %>% filter(ICER <= 700)
under800 <- sim.out.df %>% filter(ICER <= 800)
```


####################################################################################### Per Diagnosis Figures #################### #################################################################

```{r ICER values}
ICERdx<- sim.out.df %>%
  select(`Incr # Tested`, `Incr Total Cost`, `ICER Dx`)
colnames(ICERdx)<-c("Dx Incremental Effectiveness","Dx Incremental Cost", "Dx Ratio")

mean(ICERdx$`Dx Incremental Effectiveness`)
mean(ICERdx$`Dx Incremental Cost`)
mean(ICERdx$`Dx Ratio`)

median(ICERdx$`Dx Ratio`)
quantile(ICERdx[,3],0.025)
quantile(ICERdx[,3],0.975)

print("Median Cost per Dx, Decen = ") 
median(ICER.df$Cost.Trmt.Dec)
quantile(ICERdx.df[,4],0.025)
quantile(ICERdx.df[,4],0.975)

print("Median Cost per Dx, Cen = ") 
median(ICERdx.df$Cost.Trmt.Cen)
quantile(ICERdx.df[,5],0.025)
quantile(ICERdx.df[,5],0.975)
```

```{r Plot}
dataEllipse(ICERdx[,1],ICERdx[,2],
     xlab="Incremental Number of TB Diagnoses",
     ylab="Incremental Total Costs ($)",
     main="Incremental Cost-Effectiveness",
     pch=16,xaxs="i",yaxs="i",
     levels = 0.95,
     col=c("azure4", "blue"))
abline(h=0,lty=2)
abline(v=0,lty=2)

```


```{r CE Acceptability Curve}
acceptdx <- ICERdx %>%
  filter(ICERdx[,2]>=0 & ICERdx[,1]>=0)

acceptdx <- acceptdx %>%
  select(`Dx Ratio`)

acceptdx0 <- ICERdx %>%
  filter(ICERdx[,2]<=0 & ICERdx[,1]>=0) %>%
  mutate("Dx Ratio" = 0) %>%
  select(`Dx Ratio`)

acceptdxinf <- ICERdx %>%
  filter(ICERdx[,1]<=0) %>%
  mutate("Dx Ratio" = Inf) %>%
  select(`Dx Ratio`)

acceptable1 <- rbind(acceptdx, acceptdx0, acceptdxinf)

acceptable1 <- data.matrix(acceptable1)

plot(ecdf(acceptable1),
     xlim=c(0,quantile(acceptable1[acceptable1!=Inf],probs=0.99)),
     ylim=c(0,1),
     xlab="Willingness to Pay Threshold\n(per Additional TB Case Detected)",
     ylab="Probability of being\nCost-Effective",
     main="Cost-Effectiveness Acceptability Curve",
     xaxs="i",yaxs="i",
     col=rgb(.5,.5,.5,.6)
)
```



```{r Calculate our beta distribution values}
#First calculate the Y value (mode) based on a desired peak/PE, X
yvalue <- function(x, min, max) {
  y <- ((x-min)/(max-min))
  return(y)
}
#Where y = mode of the distribution

betavalue <- function(a, y){
  beta <- ((a - 1)/y) - a + 2
  return(beta)
}
#This function gives us our Beta value for each parameter based on our desired mode

#UPDATED WITH INFLATION

#For ssm total
yvalue(1.38, 0.27, 3.71)
betavalue(4, 0.3227)

#For total number tested
#yvalue(4137, 3000, 5000) #0.4444
#betavalue(4, 0.5685) #3.277

#For proprtion tested, centralized arm
#yvalue(1, 0.995, 1) #0.5
#betavalue(4, 1) #4

#Central proportion TB+
#yvalue(0.0457, 0.0342, 0.057125) #0.5016358
#betavalue(4, 0.5016358) #3.980434

#For proprtion tested, decentralized arm
#yvalue(0.9362, 0.8862, 0.9862) #0.5
#betavalue(4, 0.5) #4

#Decen proportion TB+
#yvalue(0.0602, 0.04515, 0.07525) #0.5
#betavalue(4, 0.5) #4

#Central Consumable Costs
#yvalue(12.05,11.67,12.53)
#betavalue(4, 0.4412941) #4.89

#Central Staff Costs
#yvalue(0.61, 0.09, 1.49) #0.3717
#betavalue(4, 0.3714286) #6.076922

#Central Equipment Costs
#yvalue(5565.24,5496.87,5666.82)
#betavalue(4, 0.4023) #5.457

#Central Building Costs
#yvalue(0.35, 0.18,0.89)
#betavalue(4,0.2394366) #10.52941

#Central Overhead Costs
#yvalue(0.011,0.01, 0.04)
#betavalue(4,0.03333333) #88

#Central transport cost
#yvalue(1.66, 1.25, 2.08)
#betavalue(4, 0.5) #4

#Decen consumable costs
#yvalue(10.84,10.82,10.98)
#betavalue(4, 0.125) #22

#Decen staff costs
#yvalue(0.51,0.19,0.83)
#betavalue(4, 0.5)

#Decen equipment costs
#yvalue(6.79, 5.23, 11.20)
#betavalue(4, 0.2613065)

#Decen building costs
#yvalue(0.03,0.02,0.06)
#betavalue(4,0.25) #10

#Decen overhead cost
#yvalue(0.03, 0.02, 0.05)
#betavalue(4, 0.3333333) #7

#Decen implementation cost
#yvalue(1.47, 1.13, 2.43)
#betavalue(4, 0.2615385) #9.470587

#Decen maintenance cost
#yvalue(0.79, 0.42, 1.96)
#betavalue(4, 0.2402597) #10.48649

```

```{r probabilistic data collection}
prob.outcomes <- sim.out.df %>% arrange(`Prop who are tested`)
#Change the arrange command to variable of interest
#`Number presenting for care`
#`Decen Proportion 1ary outcome`
#`Cen Proportion 1ary outcome`
#`Decen Consumable costs`
#`Decen Staff costs`
#`Decen Build costs`
#`Decen Overhead costs`
#`Decen Main costs`
#`Decen Proportion Pos`
#`Prop who are tested`
#`Cen Proportion Pos`

prob.decile1 <- prob.outcomes[1:1000,]
prob.decile2 <- prob.outcomes[1001:2000,]
prob.decile3 <- prob.outcomes[2001:3000,]
prob.decile4 <- prob.outcomes[3001:4000,]
prob.decile5 <- prob.outcomes[4001:5000,]
prob.decile6 <- prob.outcomes[5001:6000,]
prob.decile7 <- prob.outcomes[6001:7000,]
prob.decile8 <- prob.outcomes[7001:8000,]
prob.decile9 <- prob.outcomes[8001:9000,]
prob.decile10 <- prob.outcomes[9001:10000,]

print("Decentralized PP Costs")
median(prob.decile1$`Decen Per Pt costs w/ error`)
median(prob.decile2$`Decen Per Pt costs w/ error`)
median(prob.decile3$`Decen Per Pt costs w/ error`)
median(prob.decile4$`Decen Per Pt costs w/ error`)
median(prob.decile5$`Decen Per Pt costs w/ error`)
median(prob.decile6$`Decen Per Pt costs w/ error`)
median(prob.decile7$`Decen Per Pt costs w/ error`)
median(prob.decile8$`Decen Per Pt costs w/ error`)
median(prob.decile9$`Decen Per Pt costs w/ error`)
median(prob.decile10$`Decen Per Pt costs w/ error`)

print("Centralized PP Costs")
median(prob.decile1$`Cen Per Pt costs w/ error`)
median(prob.decile2$`Cen Per Pt costs w/ error`)
median(prob.decile3$`Cen Per Pt costs w/ error`)
median(prob.decile4$`Cen Per Pt costs w/ error`)
median(prob.decile5$`Cen Per Pt costs w/ error`)
median(prob.decile6$`Cen Per Pt costs w/ error`)
median(prob.decile7$`Cen Per Pt costs w/ error`)
median(prob.decile8$`Cen Per Pt costs w/ error`)
median(prob.decile9$`Cen Per Pt costs w/ error`)
median(prob.decile10$`Cen Per Pt costs w/ error`)

print("Decentralized Total Cost")
median(prob.decile1$`Decen Total costs w/ error`)
median(prob.decile2$`Decen Total costs w/ error`)
median(prob.decile3$`Decen Total costs w/ error`)
median(prob.decile4$`Decen Total costs w/ error`)
median(prob.decile5$`Decen Total costs w/ error`)
median(prob.decile6$`Decen Total costs w/ error`)
median(prob.decile7$`Decen Total costs w/ error`)
median(prob.decile8$`Decen Total costs w/ error`)
median(prob.decile9$`Decen Total costs w/ error`)
median(prob.decile10$`Decen Total costs w/ error`)

print("Centralized Total Cost")
median(prob.decile1$`Cen Total costs w/ error`)
median(prob.decile2$`Cen Total costs w/ error`)
median(prob.decile3$`Cen Total costs w/ error`)
median(prob.decile4$`Cen Total costs w/ error`)
median(prob.decile5$`Cen Total costs w/ error`)
median(prob.decile6$`Cen Total costs w/ error`)
median(prob.decile7$`Cen Total costs w/ error`)
median(prob.decile8$`Cen Total costs w/ error`)
median(prob.decile9$`Cen Total costs w/ error`)
median(prob.decile10$`Cen Total costs w/ error`)

print("ICER")
median(prob.decile1$`ICER`)
median(prob.decile2$`ICER`)
median(prob.decile3$`ICER`)
median(prob.decile4$`ICER`)
median(prob.decile5$`ICER`)
median(prob.decile6$`ICER`)
median(prob.decile7$`ICER`)
median(prob.decile8$`ICER`)
median(prob.decile9$`ICER`)
median(prob.decile10$`ICER`)
```